\documentclass[a4paper, 12pt]{article}
\usepackage{cmap}
\usepackage[12pt]{extsizes}			
\usepackage{mathtext} 				
\usepackage[T2A]{fontenc}			
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}
\usepackage{setspace}
\singlespacing
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools}
\usepackage{fancyhdr}
\usepackage{soulutf8}
\usepackage{euscript}
\usepackage{mathrsfs}
\usepackage{listings}
\pagestyle{fancy}
\usepackage{indentfirst}
\usepackage[top=10mm]{geometry}
\rhead{}
\lhead{}
\renewcommand{\headrulewidth}{0mm}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[dvipsnames]{xcolor}

\lstdefinestyle{mystyle}{ 
	keywordstyle=\color{OliveGreen},
	numberstyle=\tiny\color{Gray},
	stringstyle=\color{BurntOrange},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\thispagestyle{empty}	
\begin{center}
	Московский авиационный институт
	
	(Национальный исследовательский университет)
	
	Факультет "Информационные технологии и прикладная математика"
	
\end{center}
\vspace{40ex}
\begin{center}
	\textbf{\large{Лабораторная работа №2 по курсу \textquotedblleft Объектно-ориентированное программирование\textquotedblright}}
\end{center}
\vspace{40ex}
\begin{flushright}
	\textit{Студент: } Живалев Е.А.
	
	\vspace{2ex}
	\textit{Группа: } М8О-206Б
	
	\vspace{2ex}
	\textit{Преподаватель: } Журавлев А.А.
	
	\vspace{2ex}
	\textit{Вариант: } 5
	
	\vspace{2ex}
	\textit{Оценка: } \underline{\quad\quad\quad\quad\quad\quad}
	
	 \vspace{2ex}
	\textit{Дата: } \underline{\quad\quad\quad\quad\quad\quad}
	
\end{flushright}

\begin{vfill}
	\begin{center}
		Москва
		
		2019
	\end{center}	
\end{vfill}
\newpage
\section{Исходный код}

Ссылка на github : https://github.com/QElderDelta/oop\_exercise\_02

\vspace{3ex}
\textbf{\large{modulo.hpp}}
\lstinputlisting[language=C++]{Modulo.hpp}

\vspace{3ex}
\textbf{\large{modulo.cpp}}
\lstinputlisting[language=C++]{Modulo.cpp}

\vspace{3ex}
\textbf{\large{main.cpp}}
\lstinputlisting[language=C++]{main.cpp}

\vspace{3ex}
\textbf{\large{test.cpp}}
\lstinputlisting[language=C++]{test.cpp}

\vspace{3ex}
\textbf{\large{CMakeLists.txt}}
\lstinputlisting{CMakeLists.txt}
\newpage
\section{Тестирование}
\vspace{3ex}

\textbf{test\_01.txt}:

Входнные данные:

3 5

4 5

Ожидаемый результат:

Addition:

2 mod 5

Пояснение: $ 3 + 4 = 7,\; 7 \equiv 2\;mod\;5 $

Subtraction:

4 mod 5

Пояснение: $ 3 - 4 = -1,\; -1 \equiv 4\;mod\;5 $

Multiplication:

2 mod 5

Пояснение: $ 3 \times 4 = 12,\; 12 \equiv 2\;mod\;5 $

Division:

2 mod 5

Пояснение: Необходимо найти такое $ c $, что $ (b \times c)\;mod\;5 = a\;mod\;5 $.

Легко проверяется, что $ c = 2 $, так как $ 4 \times 2 = 8, 8 \equiv 3\;mod\;5 $

First number is less

Результат:

Addition:

2 mod 5

Subtraction:

4 mod 5

Multiplication:

2 mod 5

Division:

2 mod 5

First number is less


\vspace{3ex}

\textbf{test\_02.txt} - проверка работы с отрицательными числами:

Входнные данные:

-8 5

7 5

\vspace{3ex}

Ожидаемый результат:

Addition:

4 mod 5

Пояснение: $ -8 + 7 = -11,\; -11 \equiv 4\;mod\;5 $

Subtraction:

0 mod 5

Пояснение: $ -8 - 7 = -15,\; -15 \equiv 0\;mod\;5 $

Multiplication:

4 mod 5

Пояснение: $ -8 \times 7 = -56,\; -56 \equiv 4\;mod\;5 $

Division:

2 mod 5

Пояснение: Необходимо найти такое $ c $, что $ (b \times c)\;mod\;5 = a\;mod\;5 $.

Легко проверяется, что $ c = 1 $, так как $ 7 \times 1 = 7, -8 \equiv 2\;mod\;5, 7 \equiv 2\;mod\;5 $

Numbers are equal

Пояснение: $-8 \equiv 2\;mod\;5,\;7 \equiv 2\;mod\;5$

\vspace{3ex}

Результат:

Addition:

4 mod 5

Subtraction:

0 mod 5

Multiplication:

4 mod 5

Division:

1 mod 5

Numbers are equal

\vspace{3ex}

\textbf{test\_03.txt} - проверка деления:


Входнные данные:

11 10

4 10

\vspace{3ex}

Ожидаемый результат:

Addition:

5 mod 10

Пояснение: $11 \equiv 1\;mod\;10,\;1 + 4 = 5,\; 5 \equiv 5\;mod\;10 $

Subtraction:

7 mod 10

Пояснение: $11 \equiv 1\;mod\;10,\;1 - 4 = -3,\; -3 \equiv 7\;mod\;10 $

Multiplication:

4 mod 10

Пояснение: $11 \equiv 1\;mod\;10,\;1 \times 4 = 4,\; 4 \equiv 4\;mod\;10 $

Division:

Divisor and aren't coprime, therefore division can't be made

Пояснение: Так обязательным условием существования обратного числа по данному модулю является взаимная простота этого числа и модуля, а 4 и 10 таковыми не являются, то деление произвести нельзя.

First number is less

Пояснение: $11 \equiv 1\;mod\;10,\;1,\; 1 < 4$

\vspace{3ex}

Результат:

Addition:

5 mod 10

Subtraction:

7 mod 10

Multiplication:

4 mod 10

Division:

Divisor and aren't coprime, therefore division can't be made

First number is less


\vspace{3ex}

\textbf{test\_04.txt} - проверка невозможности работы с разными модулями:

Входнные данные:

1 2

3 4

\vspace{3ex}

Ожидаемый результат:

Падение программы в результате невыполнения одного из assert'ов

\vspace{3ex}

Результат:

Addition:
lab1: /home/qelderdelta/Study/OOP/lab1/Modulo.cpp:20: Modulo Modulo::Add(const Modulo\&) const: Assertion `mod == addend.mod' failed.
Аварийный останов (стек памяти сброшен на диск)

\newpage

\section{Объяснение результатов работы программы}

При выполнении лабораторной работы были использованы следующие свойства модулярной арифметики:

\[ (a + b)\;mod\;m = ((a\;mod\;m)+(b\;mod\;m) + m)\;mod\;m \]

\[ (a * b)\;mod\;m = ((a\;mod\;m)-(b\;mod\;m) + m)\;mod\;m \]

\[ (a * b)\;mod\;m = ((a\;mod\;m)*(b\;mod\;m) + m)\;mod\;m \]

\[ (a / b)\;mod\;m = (a*b^{-1})\;mod\;m \]

В каждом случае прибавлялось m к получившемуся результату для того, чтобы избежать отрицательных чисел. Особо интересным является деление, так как его не всегда можно произвести. Делитель должен иметь обратное число, необходимым условием чего является взаимная простота его и модуля. Для нахождения обратного числа использовался расширенный алгоритм Евклида, который помимо НОДа двух числе находит такие $ x $  и $ y $, что:

\[ a \times x + b\times y = gcd(a,b) \]

И, если НОД равен 1, то обратное число равно:

\[ modInverse = (x\;mod\;m + m)\;mod\;m \]

\newpage
\section{Выводы}

В ходе выполнения лабораторной работы я  я еще раз убедился в том, что написание функций для операций - зло, ведь есть механизм переопределения операторов, который позволяет делать это намного удобнее и элегантнее. Нельзя не отметить и то, насколько пользовательские литералы могут повысить читаемость кода. Конкретно в моём случае это не так ощутимо, но при работе с единицами измерения, например, метрами, километрами и т.д. код становится значительно элегантнее. Также я познакомился с такой замечательной утилитой как gtest, которая позволяет сильно упростить написание юнит-тестов.
\end{document}